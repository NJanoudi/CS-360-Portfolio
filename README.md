# CS-360 Project Reflection

The application I developed was a mobile inventory management tool designed to meet the user's need for a simple, real-time stock-tracking solution. The primary goal was to digitize the process of managing inventory, allowing a user to log in securely, view all their items, and perform all necessary CRUD (Create, Read, Update, Delete) operations. The app was also designed to address the critical user need of loss prevention by sending an automated SMS alert when an item's quantity reached zero.

To support these user needs, I created three core screens: a secure login screen, a main inventory dashboard, and an item details screen. My UI designs kept the user in mind by promoting clarity and efficiency. For example, the login screen obscured the password field for security, and the main dashboard featured a RecyclerView for a clear, scrollable list of items and a FloatingActionButton for the obvious primary action of adding a new item. This design was successful because it provided instant feedback for all user actions—such as saving, deleting, or logging in—using Toast messages, ensuring the user always understood the result of their actions.

My coding approach was centered on the "separation of concerns." Instead of placing all logic in one file, I created a modular system: a DatabaseHelper class to contain all SQL and database logic, a model class (InventoryItem) to act as a blueprint for the data, separate Activity classes for each screen's controller logic, and a specialized InventoryAdapter to manage the RecyclerView. This strategy of separating the data, view, and controller logic is one I will apply in all my future work, as it makes the code significantly easier to debug, maintain, and scale.

I tested my code incrementally in the Android Emulator after implementing each major feature. This process was vital because it revealed bugs at the earliest possible moment. For instance, after building the "Create" feature, testing immediately revealed that the main list wasn't refreshing with the new item. This challenge required me to innovate beyond the initial plan. The solution was to learn and apply the Android Activity Lifecycle, moving the data-loading logic from the onCreate method to onResume and clearing the list before reloading. This ensured the data was always fresh when the user returned to the screen.

The specific component where I most successfully demonstrated my knowledge was the InventoryAdapter. This single class managed the complex ViewHolder pattern for list efficiency, handled multiple distinct click listeners (one for the delete button on each row and another for the entire row to trigger an edit), and used a custom interface (OnItemClickListener) to communicate from the adapter back to the InventoryActivity. This component was the functional "engine" of the main screen and brought together several advanced development concepts.
